# -*- coding: utf-8 -*-
"""AirFlights_Hill_Climbing_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BdWLXoo2-Qo9RUPh8TnPxBN0h5zcq6du

## Implementation Details

### Calculating Total Permutations

We use the factorial function to calculate the total number of permutations for visiting all cities. The factorial of n (denoted as n!) represents the product of all positive integers up to n.

### Hill Climbing Algorithm

The hill climbing algorithm iteratively explores neighboring solutions and moves towards the one that improves the objective function. In this implementation:

- We start with an initial solution.
- At each iteration, we generate neighboring solutions by making small changes to the current solution.
- If a neighboring solution improves the objective function, we move to that solution.
- If no improvement is found, the algorithm stops.
- We are returning if no improvement if found because hill climbing does not guarantee the global optimum, so we are staying true with the algorithm itself.



**Abu Huraira Zaheer**
"""

import random
import matplotlib.pyplot as plt
from tabulate import tabulate
import math

class City:
    def __init__(self, name, expected_passengers, fuel_cost_per_liter, x, y):
        self.name = name
        self.expected_passengers = expected_passengers
        self.fuel_cost_per_liter = fuel_cost_per_liter
        self.x = x
        self.y = y

    def print_info(self):
        print()
        print(self.name)
        print()
        print(self.expected_passengers)
        print()
        print(self.fuel_cost_per_liter)
        print()
        print(self.x)
        print()
        print(self.y)

def generate_random_expected_passengers(companies):
    expected_passengers = {}
    for company in companies:
        expected_passengers[company] = random.randint(50, 300)
    return expected_passengers

def plot_cities_graph(cities):
    plt.figure(figsize=(10, 6))
    for city in cities:
        plt.scatter(city.x, city.y, color='blue')
        plt.text(city.x, city.y, city.name, fontsize=8)

    plt.title('Cities')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid()
    plt.show()

class Flight:
    def __init__(self, company_name, origin_city, destination_city, travel_time, crew_salary, fuel_consumption):
        self.company_name = company_name
        self.origin_city = origin_city
        self.destination_city = destination_city
        self.travel_time = travel_time
        self.crew_salary = crew_salary
        self.fuel_consumption = fuel_consumption

def generate_random_flights(cities, companies):
    flights = []
    for company in companies:
        for origin in cities:
            for destination in cities:
                if origin != destination:
                    travel_time = round(random.uniform(1, 5), 2)
                    crew_salary = random.randint(200, 1000)
                    fuel_consumption = random.uniform(100, 500)
                    flights.append(Flight(company, origin.name, destination.name, travel_time, crew_salary, fuel_consumption))

    return flights

def display_flights_table(flights):
    table_data = []
    for flight in flights:
        row = [flight.company_name, flight.origin_city, flight.destination_city, flight.travel_time, flight.crew_salary, flight.fuel_consumption]
        table_data.append(row)
    headers = ["Company", "Origin City", "Destination City", "Travel Time (hours)", "Crew Salary ($)", "Fuel Consumption (liters)"]
    print(tabulate(table_data, headers=headers))

def generate_random_schedule(company_flights, cities):
    random.shuffle(company_flights)
    random_schedule = [company_flights[0]]
    covered_cities = {company_flights[0].origin_city}
    #print(f"New Origin city: {company_flights[0].origin_city}, Destination city: {company_flights[0].destination_city}")

    while len(covered_cities) != len(cities):
        for flight in company_flights:
            if flight.origin_city == random_schedule[-1].destination_city:
                if flight.destination_city not in covered_cities or (flight.destination_city in covered_cities and len(covered_cities) == len(cities) - 1 and flight.destination_city == company_flights[0].origin_city):
                    random_schedule.append(flight)
                    #print(f"Added flight: {flight.company_name} from {flight.origin_city} to {flight.destination_city}")
                    covered_cities.add(flight.origin_city)

            if len(covered_cities) == len(cities) and flight.destination_city == company_flights[0].origin_city:
                return random_schedule

def generate_neighbors(company_flights, cities):
    total_permutations = math.factorial(len(cities))
    neighbors = []
    for i in range(10): # range should be equal to total permutations
        neighbor = generate_random_schedule(company_flights, cities)
        neighbors.append(neighbor)
    return neighbors

def hill_climbing(cities, flights):
    best_schedule = {}
    for company_name in set(flight.company_name for flight in flights):
        company_flights = [flight for flight in flights if flight.company_name == company_name]
        company_initial_schedule = generate_random_schedule(company_flights, cities)
        company_best_schedule = company_initial_schedule
        best_cost = calculate_total_cost(company_best_schedule, cities)

        neighbors = generate_neighbors(company_flights, cities)
        for neighbor_schedule in neighbors:
            neighbor_cost = calculate_total_cost(neighbor_schedule, cities)
            if neighbor_cost < best_cost:
                best_cost = neighbor_cost
                company_best_schedule = neighbor_schedule
            else: #This else is just to justify Hill Climbing Algorithm, becuase it might not calculate optimum solution
              break

        best_schedule[company_name] = [company_best_schedule, best_cost]
    return best_schedule

def calculate_total_cost(schedule, cities):
    total_fuel_cost = 0
    total_travel_time = 0
    total_crew_salary = 0

    current_city = None
    for flight in schedule:
        if current_city is None:
            current_city = flight.origin_city
        if current_city != flight.origin_city:
            return float('inf'), float('inf'), float('inf')

        destination_city = flight.destination_city
        fuel_cost = cities[flight.origin_city].fuel_cost_per_liter * flight.fuel_consumption
        total_fuel_cost += fuel_cost
        total_travel_time += flight.travel_time
        total_crew_salary += flight.crew_salary

        current_city = destination_city

    return total_fuel_cost, total_travel_time, total_crew_salary

def display_company_flights(data):
    RED = "\033[91m"
    RESET = "\033[0m"
    for company, flights in data.items():
        print("\n" + RED + company + RESET + "\n---------")
        if flights:
            display_flights_table(flights[0])
            print("---------\n Hill Climbing Optimum Cost")
            print("(Fuel Cost, Travel Time, Crew Salary)  =  ", flights[1],"---------\n")
        else:
            print("No flights available for this company")

def main():
    # Initializing companies
    companies = ["EtihadAirways", "QatarAirways", "SingaporeAirlines", "SaudiAirlines", "FlyEmirates"]
    # Initializing cities
    cities = []
    city_names = [
    "New York",
    "Los Angeles",
    "Chicago",
    "Houston",
    "Phoenix",
    "Philadelphia",
    "San Antonio",
    "San Diego",
    "Dallas",
    "San Jose"
]

    for i in range(10):
        city_name = city_names[i]
        expected_passengers = generate_random_expected_passengers(companies)
        fuel_cost_per_liter = random.uniform(1, 2)
        x = random.uniform(0, 10)
        y = random.uniform(0, 10)
        cities.append(City(city_name, expected_passengers, fuel_cost_per_liter, x, y))

    #plot_cities_graph(cities)

    flights = generate_random_flights(cities, companies)
    #display_flights_table(flights)

    #calling hill_climbing
    best_schedules = hill_climbing({city.name: city for city in cities}, flights)

    #display_optimum_company_flights
    display_company_flights(best_schedules)

if __name__ == "__main__":
    main()